[{"title":"原生JS实现观察者模式中的eventEmitter","date":"2017-10-25T12:49:22.000Z","path":"2017/10/25/原生JS实现观察者模式中的eventEmitter/","text":"观察者模式是平常在开发中经常使用的一种设计模式，定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。可以保证我们代码的易复用、低耦合。 class EventEmitter { constructor(){ this.messageBox={} } on(eventName, func){ let callbacks=this.messageBox[eventName]||[]; callbacks.push(func); this.messageBox[eventName]=callbacks; } emit(eventName, ...args){ let callbacks=this.messageBox[eventName]; if(callbacks.length&gt;0){ callbacks.forEach((callback)=&gt;callback(...args)) } } off(eventName,func){ let callbacks = this.messageBox[eventName] let index=callbacks.indexOf(func) callbacks.splice(index,1) } }","tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"},{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"作用域、作用域模型及闭包的理解","date":"2017-10-23T12:59:36.000Z","path":"2017/10/23/作用域、作用域模型及闭包的理解/","text":"作用域、作用域模型及闭包的理解 作用域 先来看下面两段代码 1. var name=&apos;zhangsan&apos; function f(){ var name=&apos;lisi&apos;; alert(name); } f();//lisi alert(name);//zhangsan 2. var name=&apos;zhangsan&apos; function f(){ name=&apos;lisi&apos; alert(name) } f()//lisi alert(name)//lisi 大家对于作用域的概念肯定已经比较熟悉了，一个变量的作用域即能够访问到这个变量的区域。在上述第一段代码中，外部定义的name是全局作用域变量，而在函数内部重新定义了一个也叫name的变量，该变量的作用域为f()内部。在函数内部重新定义的变量会覆盖掉同名全局变量，相信大家在其他类型的语言中对这个例子并不陌生。第二段代码，在外部定义了name全局变量后，在函数f()内部并没有重新定义同名变量，而是修改了name的值(其实是销毁了原先的全局变量重新建立的同名全局变量，在函数内部使用“var”关键字定义的是函数域变量，不使用则定义的是全局变量)，所以执行结果会有不同。从以上例子，相信大家对作用域的概念能够有基本的理解了。但是JS的作用域概念中与其他类型语言不同的是，没有块级作用域的概念，来看下边的例子。 //c语言 int sum=0; for(int i=0;i&lt;10;i++){ sum+=i; } int j=i;//报错，访问不到i，因为i是在for循环体内定义的，只能在其内部访问，c语言具有块级作用域 //JS var sum=0; for(var i=0;i&lt;10;i++){ sum+=i; } alert(i);//10 js中在块级作用域中定义的即相当于在函数内定义，可以被外界访问。 由以上我们可以得出，ECMAScript中的作用域分为全局作用域和函数作用域，定义在任何函数外部的变量是全局作用域变量，不使用“var”关键字定义在函数内部的变量也是全局作用域变量，只有使用“var”关键字定义在函数内部的变量才是函数作用域变量，函数作用域变量会覆盖同名的全局作用域变量。全局作用域变量的可见区域是整个脚本（除了被同名函数作用域变量覆盖的区域），函数作用域变量的可见区域是函数内部（除了被内部嵌套函数中同名函数作用域变量覆盖的区域） 作用域模型执行环境在javascript中当控制流进入可执行代码中时，就说其进入了可执行环境，可执行代码的执行环境可组成一个逻辑上的栈结构，进入一个函数，便将当前函数的执行环境压栈。当前执行代码的执行环境总是在栈顶，当函数执行完毕之后，当前函数的执行环境弹栈并销毁，一般栈底是全局执行环境。 变量对象上边讲到执行环境，其实每个执行环境都有一个相关的变量对象，其实在执行环境栈中存的是指向该变量对象的指针。这个变量对象中有与该执行环境有关的一切函数及变量。上面我们所写的代码的执行环境栈中有两个执行环境，分别是全局执行环境指针和函数f()的执行环境指针，分别指向全局变量对象和函数f()的变量对象。 作用域链在上面代码中我们说当在函数执行环境中定义与全局环境同名的变量时，局部的变量会覆盖掉全局环境的变量。具体是怎么实现的呢，就是通过作用域链。其实在每个执行环境都会有一个相关的作用域链(一般是在执行环境中有一个scope指针指向此链)。这个作用域链你可以想象为和执行环境栈类似的指针栈。栈中每个元素都是指向某个执行环境变量对象的指针。栈顶是指向当前执行环境变量对象的指针，下一个元素是上一层执行环境的变量对象，栈底是全局执行环境的变量对象。然后当在一个执行环境中要利用一个变量或者函数时，先在作用域链的栈顶指针指向的变量对象中寻找(即当前执行环境)，如果找到则返回，找不到则继续沿着作用域链寻找，直到全局作用域，如果全局作用域中也没有则报undefined。 当ECMAScript开始执行时，创建一个全局执行环境和全局变量对象；后面每次进入一个函数时（这个函数被调用），则创建一个当前函数的执行环境并压入栈，同时创建此执行环境的变量对象和作用域链，作用域链的创建规则是复制上一层环境的作用域链，并将指向本环境变量对象的指针放到链首；离开函数时，从栈中弹出此执行环境并销毁，同时销毁环境的变量对象和作用域链。 闭包var name=&apos;zhangsan&apos; function f(){ var name=&apos;lisi&apos; alert(name) return function(){ alert(name) } } var x=f();//lisi alert(name);//zhangsan x();//lisi 这段代码中，函数f会返回一个匿名函数，在匿名函数中会alert一下name。在此处我们首先要明白此处匿名函数alert的是哪个name，根据我们上述的规则，此处很明显是引用的是f()中定义的name。此处仔细分析会发现一个问题var x=f()，执行完之后控制流会离开函数f()，那么函数f的变量对象就应该被销毁了，那么x()还可以访问到f()中的变量name。根据上边我们所说的作用域链原则，匿名函数的作用域链中含有三个指针，第一个是指向自身变量对象，第二个是指向函数f()的变量对象，第三个是全局变量对象。而且x是全局变量，当f()执行完后，x不会被销毁，而且在赋值时匿名函数的作用域链已经建立，并且对函数f()的变量对象有引用，所以虽然f()的执行变量和作用域链在f()执行完毕后会被销毁，但是f()的变量对象不会被销毁回收，因为匿名函数的作用域链对其有引用。所以匿名函数可以访问到f()当中的name。当匿名函数执行完毕后，它回和匿名函数的作用域链一同销毁。这就是闭包，因为闭包经常用匿名函数来实现，所以可以把闭包叫做可以访问其他作用域中变量的匿名函数。但是闭包会比较耗内存，因为会同时保持好几个变量对象同时存在。","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"export export default exports module.exports区别与联系","date":"2017-09-28T09:05:00.000Z","path":"2017/09/28/export-export-default-exports-module-exports区别与联系/","text":"对几种模块导入导出方式的小梳理 前言 以前自己在写nodejs服务端还有最近在学习react的时候经常用到几种模块的导入导出方式，感觉有点混乱，特地写下此文来梳理一下。 总括在具体描述如何使用以及区别之前我们首先要搞清楚这几个分别属于哪些规范。 —- 导出 导入 commonJS module.exports exports require ES6 export export default import 通过上述的表格应该能够将这几种导入导出关系的对应以及所属规范弄清楚，接下来便具体介绍一下如何使用 commonJS简述commonJS为服务端模块规范，为同步加载方式，只有在加载完成后才能继续往下执行。NodeJS应用了commonJS规范。commonJS更加详细的介绍留待以后再写，想了解的可以移步 commonJS。 module.exports在commonJS中认为一个文件即为一个模块，该模块自成作用域，在此模块内定义的函数、变量等等都是私有的，对外部模块不可见。但是每个模块内都有一个module对象，该对象即代表了当前模块，该对象的exports属性是模块提供的对外的接口。即如果外部模块如想访问该模块内部的数据，该模块需要通过module.exports导出，然后其他模块通过require导入之后才能使用。 //a.js var name=&quot;zhangsan&quot;; module.exports.name=name;//通过module.exports导出 //b.js //在模块b中若想引用模块a中的变量需要通过require加载 var a=require(&quot;./a&quot;)//默认文件是.js文件所以只需写a即可，此外需要注意此处可以是绝对路径也可以是相对路径 var name=a.name; alert(name);//zhangsan exports exports实际上是模块内部指向module.exports的一个变量。即在模块内部实际上有一行代码var exports=module.exports,故我们在用exports变量时应注意不要重新定义exports变量，以免切断了两者之间的关联。上述代码中，a模块导出代码可以改为: exports.name=name;。 ES6export与importexport是ES6中提供的模块导出的接口，当前模块内定义的变量若想被外部使用，需要用export导出。外部模块若想利用当前模块内的变量需要使用import导入当前模块用export导出的变量，导入时必须要知道要导入的变量的名字,并且放在{}中。 //a.js var name=&quot;zhangsan&quot;; export {name}; //必须要将变量放在 {}中导出，否则 export name导出的是&quot;zhangsan&quot;字符串,外部模块无法获取到name变量。 //b.js import {name} from &quot;./a.js&quot;; alert(name);//&quot;zhangsan&quot; export default 上边提到在导出时不能直接export name，必须要将name放在{}中。否则导出的只是&quot;zhangsan&quot;。但是如果我们在name前加上default，那么便可以了。实际上这是给&quot;zhangsan&quot;起了个系统默认变量名default，即default代表了&quot;zhangsan&quot;。很明显default只能有一个值，所以在一个模块(一个js文件)中default只能有一个值，即只能使用一次export default。 在导入时，系统默认输出的default变量允许你起任何名字。不用必须知道原模块内变量的名字。 //a.js var name=&quot;zhangsan&quot;; export default name; //b.js import name1 from &quot;./a.js&quot;; alert(name1);//&quot;zhangsan&quot; 参考：http://www.php.cn/js-tutorial-357671.html","tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"},{"name":"CommonJS","slug":"CommonJS","permalink":"http://yoursite.com/tags/CommonJS/"},{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"JS数据类型","date":"2017-09-21T16:32:18.000Z","path":"2017/09/22/JS数据类型/","text":"理解Javascript中的基本数据类型与引用类型 理解基本类型与引用类型 ECMAScript中有两种数据类型的值，一种是基本类型，另一种是引用类型。基本类型指的是简单的数据段，引用类型指的是可能由多个值构成的对象。 基本类型 基本类型有5种，即 String Number Boolean Null Underfined。基本类型的值只能是单独的数据段，不能在其上添加属性值。与引用类型作对比，引用类型是可以在其上添加属性值的。 基本数据类型是按值访问的，所以存放在基本数据类型的变量中的事具体的值，我们可以直 接操作变量中的值。 var num1=5; var num2=num1; 如上代码中创建了一个num1变量并赋值5，然后将其复制到新创建的num2中,这时候的两个变量是完全两个独立的值，一个的值改变并不会影响另一个，在复制时只是将其中的值传给了另一个变量。 引用类型引用类型的值通俗点来说可以是由多个基本类型的值（也可以是对象）组成的对象。与基本类型的变量不同的是，引用类型的变量中保存的并不是对象的值。而是指向内存中对象值的引用。 var obj1=new object(); var obj2=obj1; obj1.name=&quot;zhangchong&quot;; alert(obj2.name);//zhangchong 由此复制操作可看出，在引用类型变量中存储的是指向实际存储位置的引用，复制只是将存在其中的引用赋值给了obj2。 javascript中的按值传递 先来看几个例子： 1.function addOne(num){ num++; } var num1=1; var result=addOne(num1); alert(num1);//1 alert(result);//2 2.function setAge(obj,num){ obj.age=num; } var zhangsan=new object(); setAge(zhangsan,10); alert(zhangsan.age);//10 3.function setAge(obj,num){ obj.age=num; obj=new object(); obj.age=20; } var wangwu=new object(); setAge(wangwu,8); alert(wangwu.age);//8 上面的三段代码将javascript中传递参数时的按值传递体现的淋漓尽致。 1.首先第一段中，可以看出基本类型值在传递的时候只是将自己的值传入函数中，在函数中任何的操作都不会影响到外边原本的变量。 2.第二段代码中，将引用类型的变量传入函数中，此处可能就会引起人们的不理解，js中不是按值传递，为什么在函数中做的修改会反映到外界原本的对象身上。其实此处仍然是按值传递，因为你继续看第三段代码，wangwu是按引用传递的话，那么最后alert的值应该是20。 3.所以此处到底应该怎么理解呢，首先你要先明白上边所叙述的引用类型的变量当中究竟存储的是什么。是引用！是指向内存中引用类型对象的引用。在向函数的形参传递时，只是将自身变量中保存的引用值复制了一份，给了形参。所以在第二段代码中，obj的值是指向内存中zhangsan的引用，故函数中的修改可以影响到外边的引用类型zhangsan。而第三段代码中obj.age=num，此时obj中保存的时wangwu的引用，但obj=new object已将obj中保存的引用值更新为新生成对象值的引用。所以obj.age=20修改的是新生成对象的age。而函数外的wangwu中保存的仍是原本对象的引用，故wangwu.age仍是18。","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"原生js实现选项卡","date":"2017-09-13T15:12:20.000Z","path":"2017/09/13/原生js实现选项卡/","text":"选项卡是我们在平常浏览网页时经常见到的也是自己开发时经常使用的显示格式，能够起到节省空间，与用户交互更流畅的效果。下面是我用原生的javascript写的选项卡。共有点击切换、滑动切换、滑动延时切换、自动切换四种类型。以下是具体代码（所有html css 代码共用）： 点击切换123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;点击切换选项卡&lt;/title&gt; &lt;style type=\"text/css\"&gt; *&#123; padding: 0; margin: 0; list-style:none; &#125; .card&#123; width: 298px; height: 98px; margin: 10px; border: 1px solid #eee; overflow: hidden; &#125; .nav&#123; height: 27px; /*width: 301px;*/ position: relative; background-color: #f7f7f7; overflow: hidden; &#125; .nav ul&#123; width: 301px; position: absolute; left: -1px; &#125; .nav ul li&#123; width: 58px; padding: 0 1px;/*因为点击li之后会给其增加border为了保证不变化，此处先加上padding，点击之后再取消*/ float: left; text-align: center; height: 26px; line-height: 26px; background-color: #f7f7f7; border-bottom: 1px solid #f7f7f7; cursor: pointer; &#125; .nav .select&#123;/*选中li之后的样式*/ background-color: #fff; padding: 0; border-left:1px solid #f7f7f7; border-right:1px solid #f7f7f7; border-bottom-color:#fff; &#125; .content .div&#123; margin: 10px 10px 10px 19px; &#125; .content .div ul li&#123; height: 25px; width: 134px; float: left; overflow: hidden; &#125; .div&#123; display: none; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"card\" id=\"card\"&gt; &lt;div class=\"nav\" id=\"nav\"&gt; &lt;ul&gt; &lt;li class=\"select\"&gt;张宠&lt;/li&gt; &lt;li&gt;苗悦&lt;/li&gt; &lt;li&gt;学习&lt;/li&gt; &lt;li&gt;计网&lt;/li&gt; &lt;li&gt;系统&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class=\"content\" id=\"content\"&gt; &lt;div class=\"div\" style=\"display: block;\"&gt; &lt;ul&gt; &lt;li&gt;张宠好好学习&lt;/li&gt; &lt;li&gt;张宠好好学习&lt;/li&gt; &lt;li&gt;张宠好好学习&lt;/li&gt; &lt;li&gt;张宠好好学习&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class=\"div\"&gt; &lt;ul&gt; &lt;li&gt;苗悦好好学习&lt;/li&gt; &lt;li&gt;苗悦好好学习&lt;/li&gt; &lt;li&gt;苗悦好好学习&lt;/li&gt; &lt;li&gt;苗悦好好学习&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class=\"div\"&gt; &lt;ul&gt; &lt;li&gt;张宠好好加油&lt;/li&gt; &lt;li&gt;张宠好好加油&lt;/li&gt; &lt;li&gt;张宠好好加油&lt;/li&gt; &lt;li&gt;张宠好好加油&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class=\"div\"&gt; &lt;ul&gt; &lt;li&gt;苗悦好好加油&lt;/li&gt; &lt;li&gt;苗悦好好加油&lt;/li&gt; &lt;li&gt;苗悦好好加油&lt;/li&gt; &lt;li&gt;苗悦好好加油&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class=\"div\"&gt; &lt;ul&gt; &lt;li&gt;张爸爸好好学习&lt;/li&gt; &lt;li&gt;张爸爸好好学习&lt;/li&gt; &lt;li&gt;张爸爸好好学习&lt;/li&gt; &lt;li&gt;张爸爸好好学习&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;script type=\"text/javascript\"&gt;//单独定义$用id来获取元素function $(id)&#123; return typeof id===\"string\"?document.getElementById(id):id;&#125;window.onload=function () &#123; //首先将所有的li和div获得并存在数组中，因为点击效果正是点在个li上，来切换div var lis=$(\"nav\").getElementsByTagName(\"li\"); var divs=$(\"content\").getElementsByTagName(\"div\"); for(var i=0;i&lt;lis.length;i++)&#123;//用循环的方式给每个li定义点击事件 lis[i].id=i;//自定义属性，给每个li定义id属性，以给后来显示哪个div做准备 lis[i].onclick=function()&#123; //再给li赋予新类名之前先把各个li的类名清空，使其恢复样式恢复原始状态，当点击哪个时再给该li赋予新类名 for(var j=0;j&lt;lis.length;j++)&#123; lis[j].className=\"\"; &#125; //this表示当前li this.className=\"select\"; //与上相同先把各个div的display值赋为none，然后再把当前点击li对应的div的display赋值为block for(var j=0;j&lt;divs.length;j++)&#123; divs[j].style.display=\"none\"; &#125; divs[this.id].style.display=\"block\";//this.id为当前被点击的li对应的id属性 &#125; &#125;&#125;&lt;/script&gt;&lt;/html&gt; 2.滑动切换1234567891011121314151617181920212223&lt;script type=\"text/javascript\"&gt; function $(id)&#123; return typeof id===\"string\"?document.getElementById(id):id; &#125; var lis=$(\"nav\").getElementsByTagName(\"li\"); var divs=$(\"content\").getElementsByTagName(\"div\"); window.onload=function()&#123; for(var i=0;i&lt;lis.length;i++)&#123; lis[i].id=i; lis[i].onmouseover=function()&#123; for(var j=0;j&lt;lis.length;j++)&#123; lis[j].className=\"\"; &#125; this.className=\"select\"; for(var i=0;i&lt;divs.length;i++)&#123; divs[i].style.display=\"none\"; &#125; divs[this.id].style.display=\"block\"; &#125; &#125; &#125;&lt;/script&gt;&lt;/html&gt; 滑动切换与刚才点击切换代码基本一致只是将onclick事件更换为onmouseover3.延时滑动切换 延时滑动切换与滑动切换的区别是，只有当用户鼠标滑到当前选项下并停留稍许时间才会切换内容，以免用户误滑或快速经过也切换内容，提高用户体验. 12345678910111213141516171819202122232425262728293031323334&lt;script type=\"text/javascript\"&gt; function $(id)&#123; return typeof id===\"string\"?document.getElementById(id):id; &#125; //延时切换主要是加定时器来实现的 window.onload=function()&#123; var timer=null;//用来存储定时器 var lis=$(\"nav\").getElementsByTagName(\"li\"); var divs=$(\"content\").getElementsByTagName(\"div\"); if (lis.length!=divs.length) return;//如果选项卡的选项数目与内容数目不对应，就return for(var i=0;i&lt;lis.length;i++)&#123; lis[i].id=i; lis[i].onmouseover=function()&#123; var that=this;//解决后面调用window对象而不能再直接用this的问题 //如果有待执行的定时器先清除，通过此办法可以防止鼠标用户快速经过的问题 if (timer) &#123; clearTimeout(timer); timer=null; &#125; //设置定时器，切换li的类名和更换div的display值将在550ms后执行 timer=setTimeout(function()&#123; for(var j=0;j&lt;lis.length;j++)&#123; lis[j].className=\"\"; divs[j].style.display=\"none\"; &#125; that.className=\"select\"; divs[that.id].style.display=\"block\"; &#125;,550); &#125; &#125; &#125;&lt;/script&gt;&lt;/html&gt; 4.自动切换 自动切换类似于轮播图，是其可以自动切换选项卡内的不同内容，同时当用户鼠标停留其上又可以显示当前选项的内容，而当鼠标离开后又可以自动轮播。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;script type=\"text/javascript\"&gt; function $(id)&#123; return typeof id===\"string\"?document.getElementById(id):id; &#125; window.onload=function()&#123; var index=0;//设置变量用来为轮播当下表索引 var timer=null;//存储定时器 var lis=$(\"nav\").getElementsByTagName(\"li\"); var divs=$(\"content\").getElementsByTagName(\"div\"); if (lis.length!=divs.length) return; for(var i=0;i&lt;lis.length;i++)&#123; lis[i].id=i;//与前面功能相同此处用来启用用户鼠标滑动事件 lis[i].onmouseover=function()&#123; clearInterval(timer); for(var j=0;j&lt;lis.length;j++)&#123; lis[j].className=\"\"; divs[j].style.display=\"none\"; &#125; console.log(this); this.className=\"select\"; divs[this.id].style.display=\"block\"; index=this.id;//此处的目的是为了使用户鼠标离开后能从当前鼠标停留处继续向后轮播 &#125; lis[i].onmouseout=function()&#123;//鼠标离开后重新开始轮播 timer=setInterval(function()&#123;//设置定时器，此处注意setTimeout与setInterval的区别 index++; if(index&gt;=lis.length)&#123;index=0;&#125;; for(var j=0;j&lt;lis.length;j++)&#123; lis[j].className=\"\"; divs[j].style.display=\"none\"; &#125; lis[index].className=\"select\"; divs[index].style.display=\"block\"; &#125;,2000); &#125; &#125; if (timer) &#123;//清除先前的定时器 clearInterval(timer); timer=null; &#125; timer=setInterval(function()&#123;//每2000ms执行一次 index++; if(index&gt;=lis.length)&#123;index=0;&#125;; for(var j=0;j&lt;lis.length;j++)&#123; lis[j].className=\"\"; divs[j].style.display=\"none\"; &#125; lis[index].className=\"select\"; divs[index].style.display=\"block\"; &#125;,2000); &#125;&lt;/script&gt;&lt;/html&gt;","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"css、js实现下拉菜单","date":"2017-09-13T08:43:32.000Z","path":"2017/09/13/css、js实现下拉菜单/","text":"css和js实现下拉菜单 下拉菜单是我们经常使用的一种小实例，这里自己用css和介绍分别实现。 css实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;html实现菜单&lt;/title&gt; &lt;style type=\"text/css\"&gt; *&#123; margin: 0; padding: 0; list-style: none; text-align: center; font-size: 14px; text-decoration: none; &#125; .nav&#123; height: 40px; width: 550px; background-color: #4D4D4B; padding:0 20px; &#125; .nav-1&gt;li&#123; float: left; width: 20%; line-height: 40px; &#125; a&#123; color: #fff; cursor: pointer; display: block; &#125; a:hover&#123; background-color:blue; &#125; .nav-1&gt;li ul&#123; display: none; &#125; .nav-1&gt;li ul li&#123; background-color: #4D4D4B; margin: 2px; &#125; .nav-1&gt;li:hover ul&#123; display: block; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"nav\"&gt; &lt;ul class=\"nav-1\"&gt; &lt;li&gt; &lt;a href=\"#\"&gt;张宠&lt;/a&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=\"#\"&gt;数据结构&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;数据结构&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;数据结构&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;数据结构&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=\"\"&gt;苗悦&lt;/a&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=\"#\"&gt;数据结构&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;数据结构&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;数据结构&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;数据结构&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=\"\"&gt;张宠&lt;/a&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=\"#\"&gt;数据结构&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;数据结构&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;数据结构&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;数据结构&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=\"\"&gt;苗悦&lt;/a&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=\"#\"&gt;数据结构&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;数据结构&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;数据结构&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;数据结构&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=\"\"&gt;张宠&lt;/a&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=\"#\"&gt;数据结构&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;数据结构&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;数据结构&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;数据结构&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 当鼠标不经过时display属性设为none，鼠标离开时display属性设为block.注意下hover的放置的位置即可。 js实现 123456789101112131415161718192021222324252627 function showMenu(item)&#123; item.style.display=\"block\";&#125;function hideMenu(item)&#123; item.style.display=\"none\"&#125;var x=document.getElementsByClassName(\"nav-1\")[0];var mouse=x.getElementsByClassName(\"mouse\");var data=x.getElementsByTagName(\"ul\");window.onload=function()&#123; for (var i = 0; i &lt; data.length; i++) &#123; console.log(data[i]); console.log(mouse[i]); mouse[i].onmouseover=function(num)&#123; return function() &#123; showMenu(data[num]); &#125; &#125;(i) mouse[i].onmouseout=function(num)&#123; return function() &#123; hideMenu(data[num]); &#125; &#125;(i) &#125; &#125; 首先获取到要经过的元素和要隐藏的元素。然后循环设置鼠标进过和离开事件。这个地方有个关键之处，即在设置mouse[i]的mouseover mouseout事件时的下标索引时要注意。如果直接： 12345678for (var i = 0; i &lt; data.length; i++) &#123; mouse[i].onmouseover=function()&#123; showMenu(data[i]); &#125; mouse[i].onmouseout=function()&#123; hideMenu(data[i]); &#125; &#125; 此时`showMenu[i]`中所有的i值都为最后的`data.length`，因为当for循环结束后，此时`showMenu[i]`的i会沿着作用域链向上查找，for循环中的i在循环结束后依然存在，所以此时沿着作用域链查找到i，此时的i为`data.length`。 所以用了闭包来解决此问题，即上面的正确代码。此时将闭包包含在一个匿名函数中，并且此匿名函数包含一个参数num，并按值传入i，此时在沿着作用域链往上寻找时，便找到了num。 此外，函数绑定事件时，此种用“=”绑定，只能是匿名函数。 js3种事件绑定方式： 1. 1&lt;input onclick=\"alert('谢谢支持')\" type=\"button\" value=\"点击我，弹出警告框\" /&gt; 123456&lt;input onclick=\"myAlert()\" type=\"button\" value=\"点击我，弹出警告框\" /&gt; &lt;script type=\"text/javascript\"&gt; function myAlert()&#123; alert(\"谢谢支持\"); &#125; &lt;/script&gt; 2. 123456&lt;input id=\"demo\" type=\"button\" value=\"点击我，显示 type 属性\" /&gt; &lt;script type=\"text/javascript\"&gt; document.getElementById(\"demo\").onclick=function()&#123; alert(this.getAttribute(\"type\")); // this 指当前发生事件的HTML元素，这里是&lt;div&gt;标签 &#125; &lt;/script&gt; 3. 1elementObject.addEventListener(eventName,handle,useCapture);","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]}]